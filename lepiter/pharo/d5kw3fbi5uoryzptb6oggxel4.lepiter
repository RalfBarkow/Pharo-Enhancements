{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-07-27T10:02:38.736682-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-07-27T10:02:38.736682-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "LPk9D32EDQCbTgqODDM03g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "# Object-Oriented Programming\r- \"encapsulated modules all the way down with pure messaging\" {{gtFootnote:note=Blog comment by Alan Kay 2010-09-15 at 10:12am}}\r## Problem with Class-Based Code\rTrygve Reenskaug [on Squeak-Dev](http://forum.world.st/SmaCC-First-steps-tp4802170p4805293.html):\rThe problem with reading class oriented code (C++, Java, C#, Ruby, ..., Smalltalk) is that the code does not reveal how the system will work at runtime (polymorphism). The essence of object orientation is that objects collaborate to achieve a goal.  The DCI programming paradigm adds code for how the system works at runtime:\rA class says everything about the inner construction of an object\rbut nothing about how it is used in its interaction with other objects.\rThe new DCI context says everything about how objects are used when interacting with other objects\rbut nothing about their insides.\rClass and context separates the code into two materially independent concerns: What the system IS (classes) and what the system DOES (Contexts). BabyIDE is a programming environment that supports the DCI paradigm.  It is available in Squeak 4.5 and may be available in Pharo later.\r# References\r## [Blog comment](https://computinged.wordpress.com/2010/09/11/moti-asks-objects-never-well-hardly-ever/) by Alan Kay 2010-09-15 at 10:12am:\rI think this article raises important issues.\rA good example of a large system I consider “object-oriented” is the Internet. It has billions of completely encapsulated objects (the computers themselves) and uses a pure messaging system of “requests not commands”, etc.\rBy contrast, I have never considered that most systems which call themselves “object-oriented” are even close to my meaning when I originally coined the term.\rSo part of the problem here is a kind of “colonization” of an idea — which got popular because it worked so well in the ARPA/PARC community — by many people who didn’t take the trouble to understand why it worked so well.\rAnd, in a design-oriented field such as ours, fads are all to easy to hatch. It takes considerable will to resist fads and stay focused on the real issues.\rCombine this with the desire to also include old forms (like data structures, types, and procedural programming) and you’ve got an enormous confusing mess of conflicting design paradigms.\rAnd, the 70s ideas that worked so well are not strong enough to deal with many of the problems of today. However, the core of what I now have to call “real oop” — namely encapsulated modules all the way down with pure messaging — still hangs in there strongly because it is nothing more than an abstract view of complex systems.\rThe key to safety lies in the encapsulation. The key to scalability lies in how messaging is actually done (e.g. maybe it is better to only receive messages via “postings of needs”). The key to abstraction and compactness lies in a felicitous combination of design and mathematics.\rThe key to resolving many of these issues lies in carrying out education in computing in a vastly different way than is done today.\r——————————————————————-\rA few more comments here.\rIf you are “setting” values from the outside of an object, you are doing “simulated data structure programming” rather than object oriented programming. One of my original motivations for trying to invent OOP was to eliminate imperative assignment (at least as a global unprotected action). “Real OOP” is much more about “requests”, and the more the requests invoke goals the object knows how to accomplish, the better. “Abstract Data Types” is not OOP!\rA larger problem here is that though the invention of OOP and the coining of the term were influenced by several prior systems (including Sketchpad and Simula, and others which can be found in the history I wrote for the ACM — a nice irony it turns out!), it is quite clear that the idea of OOP did not include most of its precursors.\rWe didn’t even do all of the idea at PARC. Many of Carl Hewitt’s Actors ideas which got sparked by the original Smalltalk were more in the spirit of OOP than the subsequent Smalltalks. Significant parts of Erlang are more like a real OOP language the the current Smalltalk, and certainly the C based languages that have been painted with “OOP paint”.\rThe largest problem here is that a misapplication of a paradigm is being blamed for what is really bad language and systems designs and implementations. And I agree completely with the author that most of the features cited are really bad. But they have nothing to do with OOP.\rFor example, Smalltalk initially did not have inheritance because I thought the way it was used in Simula was all to easily the foundation of nightmares (too many different semantics from one mechanism). Instead the original Smalltalk used many LISP ideas to allow dynamic experiments with many kinds of generalizations.\rI think the remedy is to consign the current wide-spread meanings of “object-oriented” to the rubbish heap of still taught bad ideas, and to make up a new term for what I and my colleagues did.\rA smaller consideration is to notice that what is good about the original idea is still quite good, but it does require more thinking (and different thinking) and design to accomplish (but with great benefits in expressiveness, scalability and safety).\rBlaming a good idea for being difficult is like blaming the Golden Rule for not being easily able to be learned by most humans. I think the main points of both lie elsewhere.\r## [Blog comment](https://computinged.wordpress.com/2010/09/11/moti-asks-objects-never-well-hardly-ever/) by Alan Kay 2010-09-15 at 11:38am:\rI’ll try to write something more extensive after all the other writing I have to do between now and the end of October.\rBut one of my favorite aphorisms at PARC was “Simple things should be simple and complex things should be possible”.\rIf simple things aren’t simple, then bad design has been done by some tool maker.\rIf complex things aren’t possible, then the bad tool makers have not allowed you to learn and scale.\rOne question we need to ask is “How can we do something with about the mental effort it deserves and somehow then gracefully scale it and share it and protect it and maintain it?”\rAnd we can ask “How can we find out what something means and also create something that has meaning” in a straightforward way without impoverishing the result for someone else’s use?”\r45 years ago I used to ask: “If you send computer stuff 1000 miles, what do you have to send with it to make it useful?” A manual? A programmer? Some form of code? What does it “mean to mean”?\rThe thing that attracted me about whole computers was that they can do whatever a computer can do.\rMaking the interior of a computer to be virtual computers preserves this. “The parts have the same powers as the wholes”. Whereas data structures have lost this and their manifest pragmatics get in the way of many needed things.\rSo the design problem to be considered (or the way I looked at it back then) was a “have the cake and eat it too” one. For example, we wanted the number 3 to be no larger than the data version on a PDP-11 (in fact we made it smaller), but also to somehow carry its most important meanings (for both internal and external use) around with it.\rIn the most recent children’s system we did over the last decade we made one kind of “universal object” which could be used to make everything else. (This is an interesting design exercise!) And it is interesting to compare the “large comprehensive” object idea with having class object be tiny and trying to build up a universe through zillions of subclasses. The large comprehensive object idea is a little more biological (where every cell in our body contains the entire DNA and the several hundred cell specializations are done entirely by a kind of parameterization).\rAgain, a little more design has to be applied to make this work, but then it works for you over and over.\rI’m very fond of “simulation style” programming that uses ideas of McCarthy, Strachey and the later Lucid language to have transitions to future states of objects be done as functional relations, but to “model time explicitly” (rather than allowing the CPU to do it) so that (as in John’s “situation calculus”) there are no race conditions, yet actions can happen and time can progress.\rThe original Smalltalk was extensible in all areas, including syntactic (because you could make up an input grammar to receive messages), and this allowed programmers to both use and to invent styles that are suitable to the problems.\rAs an old mathematician (where this is done all the time), I’m very much in favor of this design tool as an inherent part of a programming language. Again, you have to learn how to design a bit more, but I believe that many of the biggest problems with computing today come from bad designs by non-expert designers.\rLanguage extensibility is quite compatible with strong association of meanings.\rReal Estate is location location location, Real Computing is design design design!\r## [Blog comment](https://computinged.wordpress.com/2010/09/11/moti-asks-objects-never-well-hardly-ever/) by Alan Kay 2010-09-16 at 12:25 pm:\r\rBefore the term “OO” got “colonized” it meant “something in the future pointed at by Smalltalk”. After it got vastly changed when claimed by C++, etc., and redefined by Peter Wegner (a nice guy, but not really in a place to do a good job of this), I started referring to the original branch of OO as “dynamic OO”, and later as “real OO”.\rBut I think there’s too much water over the dam, and it’s time for a completely different term. And since I think we can do a much better job of this 45 years later, the next term should be given to a qualitative improvement along these lines.\r“Dynamic” tried to call attention to several important properties, including “late-binding” and “liveness” (an example of the latter is the Internet, which has never been taken down for maintenance). Instead, like a biological system it changes, grows, repairs, etc., as a living organism and the design accommodates this.\r(A glaring dumb exception is that you occasionally see an email from one’s organization saying such and such server “will be down for maintenance”, even though there is no need. Servers are cheap and they are just IDs, which means their content can be moved to other HW, renamed etc. and used while the old HW is being fixed and replaced. SysAdmins who don’t do this do not understand the Internet or “dynamic systems”.)\rIf a programming language and its DE is worth anything (meaning “powerful”) then it would be ridiculous not to have this power used for all aspects of programming including how to fix and improve itself. No change should take more than a fraction of a second to safely take effect. There is no need for text based source code, separate compliations and loading, reinitializing, etc. A decent dynamic language should be able to easily do all these things.\rBoth Interlisp and especially Smalltalk showed how this could be done to great benefit to the programming and the designs of the software systems that were being attempted.\rThe analogies to how the much more complex living systems actually scale would be very clear if computer people were willing to actually learn about complexity and scaling.\rThe way to get safety is not to make the system static, etc., but to implement “fences” which safely confine, but which can be hopped when a designer needs the next level of “meta” to make new underpinnings.\rNowadays when I get asked by large organizations about all this I try to get them to actually understand why the Internet works, and to see how a soft virtual version of the Internet would make a more ideal programming tool and environment.\rAs to your last sentence, I’ve been pointing out that “OOP” in many languages is an empty term ….\r## [Blog comment](https://computinged.wordpress.com/2010/09/11/moti-asks-objects-never-well-hardly-ever/) by Alan Kay 2011-03-06 at 1:52 pm:\rBy my original definition of “Object oriented” neither Java nor C++ is OO.\rSo why not either change your term or work within the actual definition?\r“Good OO style” in Java or C++ is an oxymoron\rAnd the “accepted wisdom” is neither wise nor correct.\rBTW, there are many under 100 line programs in Scratch and especially Etoys, that would not be as clear, easy or short without objects.\r## [Blog comment](https://computinged.wordpress.com/2010/09/11/moti-asks-objects-never-well-hardly-ever/) by Alan Kay 2011-03-06 at 1:52 pm:\rI don’t think I “misunderstand” what “maintenance” means.\rHowever, since anything can be changed in Smalltalk while it is running — and this has been true since 1976 — we have a case example that it can be done, and how to do it. (And today it can be and is done better and more comprehensively than 35 years ago.)\rTo be able to do this is one of the meanings (or connotations) of “dynamic” and “late-binding”.\r(And, by the way, for early-bound systems, the ploy of renaming servers is a way to keep service continuous for software which doesn’t know how to reconfigure.)\r## [Dr. Alan Kay on the Meaning of “Object-Oriented Programming”](http://www.purl.org/stefan_ram/pub/doc_kay_oop_en):\rE-Mail of 2003-07-23\rDr. Alan Kay was so kind as to answer my questions about the term “object-oriented programming”.\rClarification of \"object-oriented\" [E-Mail]\r\rDate: Wed, 23 Jul 2003 09:33:31 -0800\rTo: Stefan Ram [removed for privacy]\rFrom: Alan Kay [removed for privacy]\rSubject: Re: Clarification of \"object-oriented\"\r[some header lines removed for privacy]\rContent-Type: text/plain; charset=\"us-ascii\" ; format=\"flowed\"\rContent-Length: 4965\rLines: 117\r\rHi Stefan --\r\rSorry for the delay but I was on vacation.\r\rAt 6:27 PM +0200 7/17/03, Stefan Ram wrote:\r>   Dear Dr. Kay,\r>\r>   I would like to have some authoritative word on the term\r>   \"object-oriented programming\" for my tutorial page on the\r>   subject. The only two sources I consider to be \"authoritative\"\r>   are the International Standards Organization, which defines\r>   \"object-oriented\" in \"ISO/IEC 2382-15\", and you, because,\r>   as they say, you have coined that term.\r\rI'm pretty sure I did.\r\r>\r>   Unfortunately, it is difficult to find a web page or source\r>   with your definition or description of that term. There are\r>   several reports about what you might have said in this regard\r>   (like \"inheritance, polymorphism and encapsulation\"), but\r>   these are not first-hand sources. I am also aware that later\r>   you put more emphasis on \"messaging\" - but I still would like\r>   to know about \"object oriented\".\r>\r>   For the records, my tutorial page, and further distribution\r>   and publication could you please explain:\r>\r>     When and where was the term \"object-oriented\" used first?\r\rAt Utah sometime after Nov 66 when, influenced by Sketchpad, Simula, \rthe design for the ARPAnet, the Burroughs B5000, and my background in \rBiology and Mathematics, I thought of an architecture for \rprogramming. It was probably in 1967 when someone asked me what I was \rdoing, and I said: \"It's object-oriented programming\".\r\rThe original conception of it had the following parts.\r\r  - I thought of objects being like biological cells and/or individual \rcomputers on a network, only able to communicate with messages (so \rmessaging came at the very beginning -- it took a while to see how to \rdo messaging in a programming language efficiently enough to be \ruseful).\r\r  - I wanted to get rid of data. The B5000 almost did this via its \ralmost unbelievable HW architecture. I realized that the \rcell/whole-computer metaphor would get rid of data, and that \"<-\" \rwould be just another message token (it took me quite a while to \rthink this out because I really thought of all these symbols as names \rfor functions and procedures.\r\r  - My math background made me realize that each object could have \rseveral algebras associated with it, and there could be families of \rthese, and that these would be very very useful. The term \r\"polymorphism\" was imposed much later (I think by Peter Wegner) and \rit isn't quite valid, since it really comes from the nomenclature of \rfunctions, and I wanted quite a bit more than functions. I made up a \rterm \"genericity\" for dealing with generic behaviors in a \rquasi-algebraic form.\r\r  - I didn't like the way Simula I or Simula 67 did inheritance \r(though I thought Nygaard and Dahl were just tremendous thinkers and \rdesigners). So I decided to leave out inheritance as a built-in \rfeature until I understood it better.\r\rMy original experiments with this architecture were done using a \rmodel I adapted from van Wijngaarten's and Wirth's \"Generalization of \rAlgol\" and Wirth's Euler. Both of these were rather LISP-like but \rwith a more conventional readable syntax. I didn't understand the \rmonster LISP idea of tangible metalanguage then, but got kind of \rclose with ideas about extensible languages draw from various \rsources, including Irons' IMP.\r\rThe second phase of this was to finally understand LISP and then \rusing this understanding to make much nicer and smaller and more \rpowerful and more late bound understructures. Dave Fisher's thesis \rwas done in \"McCarthy\" style and his ideas about extensible control \rstructures were very helpful. Another big influence at this time was \rCarl Hewitt's PLANNER (which has never gotten the recognition it \rdeserves, given how well and how earlier it was able to anticipate \rProlog).\r\rThe original Smalltalk at Xerox PARC came out of the above. The \rsubsequent Smalltalk's are complained about in the end of the History \rchapter: they backslid towards Simula and did not replace the \rextension mechanisms with safer ones that were anywhere near as \ruseful.\r\r>\r>     What does \"object-oriented [programming]\" mean to you?\r>     (No tutorial-like introduction is needed, just a short\r>     explanation [like \"programming with inheritance,\r>     polymorphism and encapsulation\"] in terms of other concepts\r>     for a reader familiar with them, if possible. Also, it is\r>     not neccessary to explain \"object\", because I already have\r>     sources with your explanation of \"object\" from\r>     \"Early History of Smalltalk\".)\r\r(I'm not against types, but I don't know of any type systems that \raren't a complete pain, so I still like dynamic typing.)\r\rOOP to me means only messaging, local retention and protection and \rhiding of state-process, and extreme late-binding of all things. It \rcan be done in Smalltalk and in LISP. There are possibly other \rsystems in which this is possible, but I'm not aware of them.\r\rCheers,\rAlan\r\rE-Mail of 2003-07-26\rClarification of \"object-oriented\", 1 [E-Mail]\r\rDate: Sat, 26 Jul 2003 13:47:59 -0800\r\rTo: Stefan Ram [removed for privacy]\rFrom: Alan Kay [removed for privacy]\rSubject: Re: Clarification of \"object-oriented\"\r[some header lines removed for privacy]\rContent-Type: text/plain; charset=\"us-ascii\" ; format=\"flowed\"\rContent-Length: 3145\rLines: 68\r\rOne of the things I should have mentioned is that there were two main \rpaths that were catalysed by Simula. The early one (just by accident) \rwas the bio/net non-data-procedure route that I took. The other one, \rwhich came a little later as an object of study was abstract data \rtypes, and this got much more play.\r\rIf we look at the whole history, we see that the proto-OOP stuff \rstarted with ADT, had a little fork towards what I called \"objects\" \r-- that led to Smalltalk, etc.,-- but after the little fork, the CS \restablishment pretty much did ADT and wanted to stick with the \rdata-procedure paradigm. Historically, it's worth looking at the USAF \rBurroughs 220 file system (that I described in the Smalltalk \rhistory), the early work of Doug Ross at MIT (AED and earlier) in \rwhich he advocated embedding procedure pointers in data structures, \rSketchpad (which had full polymorphism -- where e.g. the same offset \rin its data structure meant \"display\" and there would be a pointer to \rthe appropriate routine for the type of object that structure \rrepresented, etc., and the Burroughs B5000, whose program reference \rtables were true \"big objects\" and contained pointers to both \"data\" \rand \"procedures\" but could often do the right thing if it was trying \rto go after data and found a procedure pointer. And the very first \rproblems I solved with my early Utah stuff was the \"disappearing of \rdata\" using only methods and objects. At the end of the 60s (I think) \rBob Balzer wrote a pretty nifty paper called \"Dataless Programming\", \rand shortly thereafter John Reynolds wrote an equally nifty paper \r\"Gedanken\" (in 1970 I think) in which he showed that using the lamda \rexpressions the right way would allow data to be abstracted by \rprocedures.\r\rThe people who liked objects as non-data were smaller in number, and \rincluded myself, Carl Hewitt, Dave Reed and a few others -- pretty \rmuch all of this group were from the ARPA community and were involved \rin one way or another with the design of ARPAnet->Internet in which \rthe basic unit of computation was a whole computer. But just to show \rhow stubbornly an idea can hang on, all through the seventies and \reighties, there were many people who tried to get by with \"Remote \rProcedure Call\" instead of thinking about objects and messages. Sic \rtransit gloria mundi.\r"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2021-07-27T10:02:38.736678-04:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2021-07-27T10:02:38.736678-04:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "OOP"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "1818aa0e-7d84-0d00-9b28-d3e20c3334de"
	}
}