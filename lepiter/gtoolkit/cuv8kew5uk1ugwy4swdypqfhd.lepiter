{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-07-27T13:51:58.715039-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-07-27T13:51:58.715039-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "oZRmQ4CEDQC5a84oD3Qt2Q=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "# Gtoolkit: Restoring Dignity to Our Poor Objects\r- Alan Kay real OOP \"encapsulated modules all the way down with pure messaging\"\r- \"The thing that attracted me about whole computers was that they can do whatever a computer can do.\rMaking the interior of a computer to be virtual computers preserves this. “The parts have the same powers as the wholes”. In the most recent children’s system we did over the last decade we made one kind of “universal object” which could be used to make everything else. (This is an interesting design exercise!) And it is interesting to compare the “large comprehensive” object idea with having class object be tiny and trying to build up a universe through zillions of subclasses. The large comprehensive object idea is a little more biological (where every cell in our body contains the entire DNA and the several hundred cell specializations are done entirely by a kind of parameterization).\"\r\rTaken together, they are a big clue to the problem GT solves. Take Pharo's poor Class object... As central and powerful as it is, if you serialized it and sent it to someone, they would not need to master an array of tools to do basic things - like explore its methods (with a class browser), read rich documentation about it (until recently they would have needed to refer to outside sources like eBooks and websites), and find references to it in their image (with a query browser). But Alan is imploring us: \"each computational unit should retain all the power of the unit that contains it!\" Class should know how to browse its methods, show its documentation, and find its references. Let's ignore the *implementation* for a moment, which would surely lead to debate about impossible to understand \"monolithic\" classes. Instead, let's focus on the *presentation* to the user. Even if we still have helper objects that browse and show documentation, from the user perspective these should be integral to the  object. Whenever you see Class, you should have *immediate* access to these. By immediate, I mean at-hand, which should aim to be as universal and with at little context switching as possible. In essence, our IDE should be shaken to its foundations by the same revolution that created our objects.\r"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2021-07-27T13:51:58.715036-04:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2021-07-27T13:51:58.715036-04:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "OO_IDE"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "e1216543-8084-0d00-b962-1e660f742dd9"
	}
}